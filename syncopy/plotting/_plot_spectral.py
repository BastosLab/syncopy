# -*- coding: utf-8 -*-
# 
# Outsourced plotting class methods from respective parent classes
# 
# Created: 2020-07-15 10:26:48
# Last modified by: Stefan Fuertinger [stefan.fuertinger@esi-frankfurt.de]
# Last modification time: <2020-07-20 14:54:56>

# Builtin/3rd party package imports
import os
import numpy as np

# Local imports
from syncopy.shared.errors import SPYValueError, SPYError, SPYTypeError, SPYWarning
from syncopy.shared.tools import layout_subplot_panels
from syncopy.plotting.spy_plotting import pltErrMsg, pltConfig, _compute_toilim_avg
from syncopy import __plt__
if __plt__:
    import matplotlib.pyplot as plt

__all__ = []


def singlepanelplot(self, trials="all", channels="all", tapers="all", toilim=None, foilim=None,
                    avg_channels=True, avg_tapers=True, interp="spline36", cmap="plasma",
                    title=None, grid=None, fig=None, **kwargs):
    """
    Coming soon...
    """
    
    # Abort if matplotlib is not available
    if not __plt__:
        raise SPYError(pltErrMsg.format("singlepanelplot"))
    
    # Ensure our binary flags are actually binary
    if not isinstance(avg_channels, bool):
        raise SPYTypeError(avg_channels, varname="avg_channels", expected="bool")
    if not isinstance(avg_tapers, bool):
        raise SPYTypeError(avg_tapers, varname="avg_tapers", expected="bool")
    
    # Pass provided selections on to `Selector` class which performs error 
    # checking and generates required indexing arrays
    self._selection = {"trials": trials, 
                       "channels": channels, 
                       "tapers": tapers,
                       "toilim": toilim,
                       "foilim": foilim}
    
    # Ensure any optional keywords controlling plotting appearance make sense
    if title is not None:
        if not isinstance(title, str):
            raise SPYTypeError(title, varname="title", expected="str")
    if grid is not None:
        if not isinstance(grid, bool):
            raise SPYTypeError(grid, varname="grid", expected="bool")

    # Get trial/channel/taper count
    trList = self._selection.trials
    nTrials = len(trList)
    chArr = self.channel[self._selection.channel]
    nChan = chArr.size
    freqArr = self.freq[self._selection.freq]
    nFreq = freqArr.size
    tpArr = self.taper[self._selection.taper]
    nTap = tpArr.size

    # Determine whether we're dealing w/tf data
    isTimeFrequency = False
    if any([t.size > 1 for t in self.time]):
        isTimeFrequency = True
        
    # Check for complex entries in data and set datatype for plotting arrays 
    # constructed below (always use floats w/same precision as data)
    if "complex" in self.data.dtype.name:
        msg = "Found complex Fourier coefficients - visualization will use absolute values."
        SPYWarning(msg)
        complexConversion = lambda x: np.absolute(x).real
        pltDtype = "f{}".format(self.data.dtype.itemsize)
        dataLbl = "Absolute Frequency [dB]"
    else:
        complexConversion = lambda x: x
        pltDtype = self.data.dtype
        useAbs = True
        dataLbl = "Power [dB]"
        
    # If we're overlaying, ensure data and plot type match up    
    if hasattr(fig, "objCount"): 
        if isTimeFrequency:
            msg = "Overlay plotting not supported fro time-frequency data"
            raise SPYError(msg)
        if not hasattr(fig, "isSpectralPlot"):
            lgl = "figure visualizing data from a Syncopy `SpectralData` object"
            act = "visualization of other Syncopy data"
            raise SPYValueError(legal=lgl, varname="fig", actual=act)
        if hasattr(fig, "multipanelplot"):
            lgl = "single-panel figure generated by `singleplot`"
            act = "multi-panel figure generated by `multipanelplot`"
            raise SPYValueError(legal=lgl, varname="fig", actual=act)
    
    # # Prepare indexing list respecting potential non-default `dimord`s
    # idx = [slice(None), slice(None), slice(None), slice(None)]
    # timeIdx = self.dimord.index("time")
    # chanIdx = self.dimord.index("channel")
    # freqIdx = self.dimord.index("freq")
    # taperIdx = self.dimord.index("taper")
    
    # import ipdb; ipdb.set_trace()
    
    # idx[chanIdx] = self._selection.channel
    # idx[freqIdx] = self._selection.freq
    # idx[taperIdx] = self._selection.taper

    # No time-frequency shenanigans: this is a simple power-spectrum (line-plot)
    if not isTimeFrequency:
        
        # Generic titles for figures
        overlayTitle = "Overlay of {} datasets"
    
        # Either create new figure or fetch existing
        if fig is None:
            fig, ax = plt.subplots(1, tight_layout=True, squeeze=True,
                                   figsize=pltConfig["singleFigSize"])
            ax.set_xlabel("Frequency [Hz]", size=pltConfig["singleLabelSize"])            
            ax.set_ylabel(dataLbl, size=pltConfig["singleLabelSize"])            
            ax.tick_params(axis="both", labelsize=pltConfig["singleTickSize"])
            ax.autoscale(enable=True, axis="x", tight=True)
            fig.objCount = 0
        else:
            ax, = fig.get_axes()        

        # Average across channels, tapers or both using local helper func
        nTime = 1
        if not avg_channels and not avg_tapers and nTap > 1:
            msg = "Either channels or trials need to be averaged for single-panel plot"
            SPYWarning(msg)
            return
        if avg_channels and not avg_tapers:
            panelTitle = "{} tapers averaged across {} channels and {} trials".format(nTap, nChan, nTrials)
            pltArr = _compute_pltArr(self, nFreq, nTap, nTime, complexConversion, pltDtype, 
                                     avg1="channel")
        if avg_tapers and not avg_channels:
            panelTitle = "{} channels averaged across {} tapers and {} trials".format(nChan, nTap, nTrials)
            pltArr = _compute_pltArr(self, nFreq, nChan, nTime, complexConversion, pltDtype, 
                                     avg1="taper")
        if avg_tapers and avg_channels:
            panelTitle = "Average of {} channels, {} tapers and {} trials".format(nChan, nTap, nTrials)
            pltArr = _compute_pltArr(self, nFreq, 1, nTime, complexConversion, pltDtype, 
                                     avg1="taper", avg2="channel")

        # Perform the actual plotting
        ax.plot(freqArr, np.log10(pltArr), label=os.path.basename(self.filename))
        ax.set_xlim([freqArr[0], freqArr[-1]])
        if grid is not None:
            ax.grid(grid)
                
        # Set plot title depending on dataset overlay
        if fig.objCount == 0:
            if title is None:
                title = panelTitle
            ax.set_title(title, size=pltConfig["singleTitleSize"])
        else:
            handles, labels = ax.get_legend_handles_labels()
            ax.legend(handles, labels)
            if title is None:
                title = overlayTitle.format(len(handles))
            ax.set_title(title, size=pltConfig["singleTitleSize"])
        
    else:
        
        
        if not avg_channels or (not avg_tapers and nTap > 1):
            msg = "Single-panel time-frequency visualization requires averaging " +\
                "across both tapers and channels"
            SPYWarning(msg)
            return
        
        tLengths = _compute_toilim_avg(self)
        nTime = tLengths[0]
        
        # asdf
        panelTitle = "Average of {} channels, {} tapers and {} trials".format(nChan, nTap, nTrials)
        pltArr = _compute_pltArr(self, nFreq, 1, nTime, complexConversion, pltDtype, 
                                 avg1="taper", avg2="channel")
        
        # import ipdb; ipdb.set_trace()
        
        fig, ax = plt.subplots(1, tight_layout=True, squeeze=True,
                               figsize=pltConfig["singleFigSize"])
        ax.set_xlabel("Time [s]", size=pltConfig["singleLabelSize"])            
        ax.set_ylabel(dataLbl, size=pltConfig["singleLabelSize"])            
        ax.tick_params(axis="both", labelsize=pltConfig["singleTickSize"])
        ax.autoscale(enable=True, axis="x", tight=True)
        fig.objCount = 0
        
        
        ax.imshow(pltArr, origin="lower", interpolation=interp, cmap=cmap)
        
        # ax.xaxis.get_major_locator().set_params(prune="lower")

    
def _compute_pltArr(self, nFreq, N, nTime, complexConversion, pltDtype,
                    avg1="channel", avg2=None):
    """
    Local helper
    """
    
    # Prepare indexing list respecting potential non-default `dimord`s
    idx = [slice(None), slice(None), slice(None), slice(None)]
    timeIdx = self.dimord.index("time")
    chanIdx = self.dimord.index("channel")
    freqIdx = self.dimord.index("freq")
    taperIdx = self.dimord.index("taper")
    
    idx[chanIdx] = self._selection.channel
    idx[freqIdx] = self._selection.freq
    idx[taperIdx] = self._selection.taper
    
    if nTime == 1:
        pltArr = np.zeros((nFreq, N), dtype=pltDtype).squeeze()         # `squeeze` in case `N = 1`
    else:
        pltArr = np.zeros((nFreq, nTime, N), dtype=pltDtype).squeeze()  # `squeeze` for `singlepanelplot`
    for trlno in self._selection.trials:
        if not self._selection._useFancy:
            trlArr = self._get_trial(trlno)[tuple(idx)]
        else:
            trlArr = self._get_trial(trlno)[idx[0], ...][:, idx[1], ...][:, :, idx[2], :][..., idx[3]]
        trlArr = trlArr.mean(axis=self.dimord.index(avg1), keepdims=True)
        if avg2:
            trlArr = trlArr.mean(axis=self.dimord.index(avg2), keepdims=True)
        pltArr += complexConversion(np.swapaxes(trlArr, freqIdx, 0).squeeze())
    return pltArr / len(self._selection.trials)
