# -*- coding: utf-8 -*-
# 
# Outsourced plotting class methods from respective parent classes
# 
# Created: 2020-07-15 10:26:48
# Last modified by: Stefan Fuertinger [stefan.fuertinger@esi-frankfurt.de]
# Last modification time: <2020-07-27 18:25:58>

# Builtin/3rd party package imports
import os
import numpy as np

# Local imports
from syncopy.shared.errors import SPYValueError, SPYError, SPYTypeError, SPYWarning
from syncopy.shared.tools import layout_subplot_panels
from syncopy.plotting.spy_plotting import pltErrMsg, pltConfig, _compute_toilim_avg
from syncopy import __plt__
if __plt__:
    import matplotlib.pyplot as plt

__all__ = []


def singlepanelplot(self, trials="all", channels="all", tapers="all", toilim=None, foilim=None,
                    avg_channels=True, avg_tapers=True, toi=None, foi=None,
                    interp="spline36", cmap="plasma", title=None, grid=None, fig=None, **kwargs):
    """
    Coming soon...
    
    overlay-plotting not supported for TF data
    """
    
    # BEGIN OF >>> _prep_specral_plots(__name__, ...)
    
    # Abort if matplotlib is not available
    if not __plt__:
        raise SPYError(pltErrMsg.format("singlepanelplot"))
    
    # Ensure our binary flags are actually binary
    if not isinstance(avg_channels, bool):
        raise SPYTypeError(avg_channels, varname="avg_channels", expected="bool")
    if not isinstance(avg_tapers, bool):
        raise SPYTypeError(avg_tapers, varname="avg_tapers", expected="bool")
    
    # Pass provided selections on to `Selector` class which performs error 
    # checking and generates required indexing arrays
    self._selection = {"trials": trials, 
                       "channels": channels, 
                       "tapers": tapers,
                       "toilim": toilim,
                       "foilim": foilim}
    
    # Ensure any optional keywords controlling plotting appearance make sense
    if title is not None:
        if not isinstance(title, str):
            raise SPYTypeError(title, varname="title", expected="str")
    if grid is not None:
        if not isinstance(grid, bool):
            raise SPYTypeError(grid, varname="grid", expected="bool")

    # Get trial/channel/taper count
    trList = self._selection.trials
    nTrials = len(trList)
    chArr = self.channel[self._selection.channel]
    nChan = chArr.size
    freqArr = self.freq[self._selection.freq]
    nFreq = freqArr.size
    tpArr = self.taper[self._selection.taper]
    nTap = tpArr.size

    # Determine whether we're dealing w/tf data
    isTimeFrequency = False
    if any([t.size > 1 for t in self.time]):
        isTimeFrequency = True
        
    # Check for complex entries in data and set datatype for plotting arrays 
    # constructed below (always use floats w/same precision as data)
    if "complex" in self.data.dtype.name:
        msg = "Found complex Fourier coefficients - visualization will use absolute values."
        SPYWarning(msg)
        complexConversion = lambda x: np.absolute(x).real
        pltDtype = "f{}".format(self.data.dtype.itemsize)
        dataLbl = "Absolute Frequency [dB]"
    else:
        complexConversion = lambda x: x
        pltDtype = self.data.dtype
        dataLbl = "Power [dB]"
        
    # If we're overlaying, ensure data and plot type match up    
    if hasattr(fig, "objCount"): 
        if isTimeFrequency:
            msg = "Overlay plotting not supported for time-frequency data"
            raise SPYError(msg)
        if not hasattr(fig, "isSpectralPlot"):
            lgl = "figure visualizing data from a Syncopy `SpectralData` object"
            act = "visualization of other Syncopy data"
            raise SPYValueError(legal=lgl, varname="fig", actual=act)
        if hasattr(fig, "multipanelplot"):
            lgl = "single-panel figure generated by `singleplot`"
            act = "multi-panel figure generated by `multipanelplot`"
            raise SPYValueError(legal=lgl, varname="fig", actual=act)

    # END OF >>> _prep_specral_plots(__name__, ...)

    # No time-frequency shenanigans: this is a simple power-spectrum (line-plot)
    if not isTimeFrequency:
        
        # Generic titles for figures
        overlayTitle = "Overlay of {} datasets"
    
        # Either create new figure or fetch existing
        if fig is None:
            fig, ax = plt.subplots(1, tight_layout=True, squeeze=True,
                                   figsize=pltConfig["singleFigSize"])
            ax.set_xlabel("Frequency [Hz]", size=pltConfig["singleLabelSize"])            
            ax.set_ylabel(dataLbl, size=pltConfig["singleLabelSize"])            
            ax.tick_params(axis="both", labelsize=pltConfig["singleTickSize"])
            ax.autoscale(enable=True, axis="x", tight=True)
            fig.isSpectralPlot = True
            fig.singlepanelplot = True
            fig.objCount = 0
        else:
            ax, = fig.get_axes()        

        # Average across channels, tapers or both using local helper func
        nTime = 1
        if not avg_channels and not avg_tapers and nTap > 1:
            msg = "Either channels or trials need to be averaged for single-panel plot"
            SPYWarning(msg)
            return
        if avg_channels and not avg_tapers:
            panelTitle = "{} tapers averaged across {} channels and {} trials".format(nTap, nChan, nTrials)
            pltArr = _compute_pltArr(self, nFreq, nTap, nTime, complexConversion, pltDtype, 
                                     avg1="channel")
        if avg_tapers and not avg_channels:
            panelTitle = "{} channels averaged across {} tapers and {} trials".format(nChan, nTap, nTrials)
            pltArr = _compute_pltArr(self, nFreq, nChan, nTime, complexConversion, pltDtype, 
                                     avg1="taper")
        if avg_tapers and avg_channels:
            panelTitle = "Average of {} channels, {} tapers and {} trials".format(nChan, nTap, nTrials)
            pltArr = _compute_pltArr(self, nFreq, 1, nTime, complexConversion, pltDtype, 
                                     avg1="taper", avg2="channel")

        # Perform the actual plotting
        ax.plot(freqArr, np.log10(pltArr), label=os.path.basename(self.filename))
        ax.set_xlim([freqArr[0], freqArr[-1]])
        if grid is not None:
            ax.grid(grid)
                
        # Set plot title depending on dataset overlay
        if fig.objCount == 0:
            if title is None:
                title = panelTitle
            ax.set_title(title, size=pltConfig["singleTitleSize"])
        else:
            handles, labels = ax.get_legend_handles_labels()
            ax.legend(handles, labels)
            if title is None:
                title = overlayTitle.format(len(handles))
            ax.set_title(title, size=pltConfig["singleTitleSize"])
        
    else:
        
        # For a single-panel TF visualization, we need to average across both tapers + channels        
        if not avg_channels and (not avg_tapers and nTap > 1):
            msg = "Single-panel time-frequency visualization requires averaging " +\
                "across both tapers and channels"
            SPYWarning(msg)
            return
        
        # Compute (and verify) length of selected time intervals and assemble array for plotting
        panelTitle = "Average of {} channels, {} tapers and {} trials".format(nChan, nTap, nTrials)
        tLengths = _compute_toilim_avg(self)
        nTime = tLengths[0]
        pltArr = _compute_pltArr(self, nFreq, 1, nTime, complexConversion, pltDtype, 
                                 avg1="taper", avg2="channel")

        # Prepare figure        
        fig, ax = plt.subplots(1, tight_layout=True, squeeze=True,
                               figsize=pltConfig["singleFigSize"])
        ax.set_xlabel("Time [s]", size=pltConfig["singleLabelSize"])            
        ax.set_ylabel("Frequency [Hz]", size=pltConfig["singleLabelSize"])            
        ax.tick_params(axis="both", labelsize=pltConfig["singleTickSize"])
        ax.autoscale(enable=True, axis="x", tight=True)
        fig.isSpectralPlot = True
        fig.singlepanelplot = True
        fig.objCount = 0
        
        # Use `imshow` to render array as image
        time = self.time[trList[0]][self._selection.time[0]]
        ax.imshow(pltArr, origin="lower", interpolation=interp, cmap=cmap, 
                  extent=(time[0], time[-1], freqArr[0], freqArr[-1]), aspect="auto")
        if grid is not None:
            ax.grid(grid)
        if title is None:
            title = panelTitle
        ax.set_title(title, size=pltConfig["singleTitleSize"])

    # Increment overlay-counter and draw figure
    fig.objCount += 1
    plt.draw()
    self._selection = None
    return fig


def multipanelplot(self, trials="all", channels="all", tapers="all", toilim=None, foilim=None,
                   avg_channels=True, avg_tapers=True, avg_trials=False, panels="channels",
                   interp="spline36", cmap="plasma", title=None, grid=None, fig=None, **kwargs):
    """
    Coming soon...
    
    overlay-plotting not supported (at all)
    """

    # >>> _prep_specral_plots(__name__, ...)
    
    
    # Abort if matplotlib is not available
    if not __plt__:
        raise SPYError(pltErrMsg.format("singlepanelplot"))
    
    # Ensure our binary flags are actually binary
    if not isinstance(avg_channels, bool):
        raise SPYTypeError(avg_channels, varname="avg_channels", expected="bool")
    if not isinstance(avg_tapers, bool):
        raise SPYTypeError(avg_tapers, varname="avg_tapers", expected="bool")
    
    # Pass provided selections on to `Selector` class which performs error 
    # checking and generates required indexing arrays
    self._selection = {"trials": trials, 
                       "channels": channels, 
                       "tapers": tapers,
                       "toilim": toilim,
                       "foilim": foilim}
    
    # Ensure any optional keywords controlling plotting appearance make sense
    if title is not None:
        if not isinstance(title, str):
            raise SPYTypeError(title, varname="title", expected="str")
    if grid is not None:
        if not isinstance(grid, bool):
            raise SPYTypeError(grid, varname="grid", expected="bool")

    # Get trial/channel/taper count
    trList = list(self._selection.trials)
    nTrials = len(trList)
    chArr = self.channel[self._selection.channel]
    nChan = chArr.size
    freqArr = self.freq[self._selection.freq]
    nFreq = freqArr.size
    tpArr = self.taper[self._selection.taper]
    nTap = tpArr.size
    
    import ipdb; ipdb.set_trace()

    # Determine whether we're dealing w/tf data
    isTimeFrequency = False
    if any([t.size > 1 for t in self.time]):
        isTimeFrequency = True
        
    # Check for complex entries in data and set datatype for plotting arrays 
    # constructed below (always use floats w/same precision as data)
    if "complex" in self.data.dtype.name:
        msg = "Found complex Fourier coefficients - visualization will use absolute values."
        SPYWarning(msg)
        complexConversion = lambda x: np.absolute(x).real
        pltDtype = "f{}".format(self.data.dtype.itemsize)
        dataLbl = "Absolute Frequency [dB]"
    else:
        complexConversion = lambda x: x
        pltDtype = self.data.dtype
        dataLbl = "Power [dB]"
        
    # If we're overlaying, ensure data and plot type match up    
    if hasattr(fig, "objCount"): 
        msg = "Overlays of multi-panel `SpectralData` plots not supported"
        raise SPYError(msg)
        # if isTimeFrequency:
        #     msg = "Overlay plotting not supported for time-frequency data"
        #     raise SPYError(msg)
        # if not hasattr(fig, "isSpectralPlot"):
        #     lgl = "figure visualizing data from a Syncopy `SpectralData` object"
        #     act = "visualization of other Syncopy data"
        #     raise SPYValueError(legal=lgl, varname="fig", actual=act)
        # if hasattr(fig, "singlepanelplot"):
        #     lgl = "multi-panel figure generated by `multipanelplot`"
        #     act = "single-panel figure generated by `singleplot`"
        #     raise SPYValueError(legal=lgl, varname="fig", actual=act)
        # if hasattr(fig, "multipanelplot"):

    # END OF >>> _prep_specral_plots(__name__, ...)

    avgFlags = [avg_channels, avg_trials, avg_tapers]
    if all(avgFlags) is False and nTap * nTrials > 1:
        error(...)

    if all(avgFlags) is True:
        msg = "Averaging across trials, channels and tapers results in " +\
            "single-panel plot. Please use `singlepanelplot` instead"
        SPYWarning(msg)
        return
        
    if isTimeFrequency:
        if sum(avgFlags) != 2: # TF needs averaging across 2/3 quantities
            error(...)
        
    # Prepare figure (same for all cases)
    if not avg_channels:
        npanels = nChan
    elif not avg_trials:
        npanels = nTrials
    else:
        npanels = nTap
    
    # Construct subplot panel layout or vet provided layout
    nrow, ncol = layout_subplot_panels(npanels, 
                                       nrow=kwargs.get("nrow", None), 
                                       ncol=kwargs.get("ncol", None))
    (fig, ax_arr) = plt.subplots(nrow, ncol, constrained_layout=False,
                                 gridspec_kw={"wspace": 0, "hspace": 0.35,
                                              "left": 0.05, "right": 0.97},
                                 figsize=pltConfig["multiFigSize"],
                                 sharex=True, sharey=True, squeeze=False)

    # Show xlabel only on bottom row of panels
    if isTimeFrequency:
        xLabel = "Time [s]"
    else:
        xLabel = "Frequency [Hz]"
    for col in range(ncol):
        ax_arr[-1, col].set_xlabel(xLabel, size=pltConfig["multiLabelSize"])
        
    # Omit first x-tick in all panels except first panel-row
    for row in range(nrow):
        for col in range(1, ncol):
            ax_arr[row, col].xaxis.get_major_locator().set_params(prune="lower")
            
    # Flatten axis array to make counting a little easier in here and make
    # any surplus panels as unobtrusive as possible
    ax_arr = ax_arr.flatten(order="C")
    for ax in ax_arr:
        ax.tick_params(axis="both", labelsize=pltConfig["multiTickSize"])
        ax.autoscale(enable=True, axis="x", tight=True)
    for k in range(npanels, nrow * ncol):
        ax_arr[k].set_xticks([])
        ax_arr[k].set_yticks([])
        ax_arr[k].set_xlabel("")
        for spine in ax_arr[k].spines.values():
            spine.set_visible(False)
    ax_arr[min(npanels, nrow * ncol - 1)].spines["left"].set_visible(True)
    
    # Monkey-patch object-counter to newly created figure
    fig.isSpectralPlot = True
    fig.multipanelplot = True
    fig.objCount = 0

    if not isTimeFrequency:

        nTime = 1
        
        if panels == "channels":
            
            if not avg_trials and avg_tapers:
                pass
            elif avg_trials and not avg_tapers:
                kwargs = {"avg1": None}
                pass
            else:
                pass
        
        elif panels == "trials":
            if not avg_channels and avg_tapers:
                N = nChan
                avgDim1 = "taper"
                avgDim2 = None
            elif avg_channels and not avg_tapers:
                N = nTap
                avgDim = "channel"
                avgDim2 = None
            else:
                N = 1
                avgDim1 = "channel"
                avgDim2 = "taper"
                
            for k, trlno in enumerate(trList):
                pltArr = _compute_pltArr(self, nFreq, N, nTime, complexConversion, pltDtype, 
                                 avg1=avgDim, avg2=avgDim2, trial=trlno)
                
                ax_arr[k].plot(freqArr, np.log10(pltArr), label=os.path.basename(self.filename))
                if grid is not None:
                    ax_arr[k].grid(grid)
                    
        else:  # panels = "tapers"
            pass
            
    
def _compute_pltArr(self, nFreq, N, nTime, complexConversion, pltDtype,
                    avg1="channel", avg2=None, trial="all", channel="all", 
                    freq="all", taper="all"):
    """
    Local helper
    """
    
    # Prepare indexing list respecting potential non-default `dimord`s
    idx = [slice(None), slice(None), slice(None), slice(None)]
    timeIdx = self.dimord.index("time")
    chanIdx = self.dimord.index("channel")
    freqIdx = self.dimord.index("freq")
    taperIdx = self.dimord.index("taper")
    
    if trial == "all":
        trList = self._selection.trials
    else:
        trList = trials
    nTrls = len(trList)
    if channel == "all":
        idx[chanIdx] = self._selection.channel
    else:
        idx[chanIdx] = np.where(self.channel == channel)[0][0]
    if freq ==  "all":       
        idx[freqIdx] = self._selection.freq
    else:
        idx[freqIdx] = [freq] * nTrls
    if taper == "all":
        idx[taperIdx] = self._selection.taper
    else:
        idx[taperIdx] = [taper] * nTrls
        
    if nTime == 1:
        pltArr = np.zeros((nFreq, N), dtype=pltDtype).squeeze()         # `squeeze` in case `N = 1`
    else:
        pltArr = np.zeros((nFreq, nTime, N), dtype=pltDtype).squeeze()  # `squeeze` for `singlepanelplot`
        
    for trlno in trList:
        if not self._selection._useFancy:
            trlArr = self._get_trial(trlno)[tuple(idx)]
        else:
            trlArr = self._get_trial(trlno)[idx[0], ...][:, idx[1], ...][:, :, idx[2], :][..., idx[3]]
        if avg1:
            trlArr = trlArr.mean(axis=self.dimord.index(avg1), keepdims=True)
        if avg2:
            trlArr = trlArr.mean(axis=self.dimord.index(avg2), keepdims=True)
        pltArr += complexConversion(np.swapaxes(trlArr, freqIdx, 0).squeeze())
    return pltArr / len(trList)
