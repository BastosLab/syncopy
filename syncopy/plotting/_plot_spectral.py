# -*- coding: utf-8 -*-
# 
# Outsourced plotting class methods from respective parent classes
# 
# Created: 2020-07-15 10:26:48
# Last modified by: Stefan Fuertinger [stefan.fuertinger@esi-frankfurt.de]
# Last modification time: <2020-07-15 17:09:38>

from syncopy.shared.errors import SPYValueError, SPYError, SPYTypeError, SPYWarning
from syncopy.shared.tools import layout_subplot_panels
from syncopy.plotting.spy_plotting import pltErrMsg, pltConfig
from syncopy import __plt__
if __plt__:
    import matplotlib.pyplot as plt

__all__ = []


def singlepanelplot(self, trials="all", channels="all", tapers="all", toilim=None, foilim=None,
                    avg_channels=True, avg_tapers=True, 
                    title=None, grid=None, fig=None, **kwargs):
    """
    Coming soon...
    """
    
    # Abort if matplotlib is not available
    if not __plt__:
        raise SPYError(pltErrMsg.format("singlepanelplot"))
    
    # Ensure our binary flags are actually binary
    if not isinstance(avg_channels, bool):
        raise SPYTypeError(avg_channels, varname="avg_channels", expected="bool")
    if not isinstance(avg_tapers, bool):
        raise SPYTypeError(avg_tapers, varname="avg_tapers", expected="bool")
    
    # Pass provided selections on to `Selector` class which performs error 
    # checking and generates required indexing arrays
    self._selection = {"trials": trials, 
                       "channels": channels, 
                       "tapers": tapers,
                       "toilim": toilim,
                       "foilim": foilim}
    
    # Ensure any optional keywords controlling plotting appearance make sense
    if title is not None:
        if not isinstance(title, str):
            raise SPYTypeError(title, varname="title", expected="str")
    if grid is not None:
        if not isinstance(grid, bool):
            raise SPYTypeError(grid, varname="grid", expected="bool")

    # Get trial/channel/taper count
    trList = self._selection.trials
    nTrials = len(trList)
    chArr = self.channel[self._selection.channel]
    nChan = chArr.size
    freqArr = self.freq[self._selection.freq]
    nFreq = freqArr.size
    tpArr = self.taper[self._selection.taper]
    nTap = tpArr.size

    # Determine whether we're dealing w/tf data
    isTimeFrequency = False
    if any([t.size > 1 for t in self.time]):
        isTimeFrequency = False

    # If we're overlaying, ensure data and plot type match up    
    if hasattr(fig, "objCount"): 
        if isTimeFrequency:
            msg = "Overlay plotting not supported fro time-frequency data"
            raise SPYError(msg)
        if not hasattr(fig, "isSpectralPlot"):
            lgl = "figure visualizing data from a Syncopy `SpectralData` object"
            act = "visualization of other Syncopy data"
            raise SPYValueError(legal=lgl, varname="fig", actual=act)
        if hasattr(fig, "multipanelplot"):
            lgl = "single-panel figure generated by `singleplot`"
            act = "multi-panel figure generated by `multipanelplot`"
            raise SPYValueError(legal=lgl, varname="fig", actual=act)
    
    # Prepare indexing list respecting potential non-default `dimord`s
    idx = [slice(None), slice(None)]
    chanIdx = self.dimord.index("channel")
    timeIdx = self.dimord.index("time")
    freqIdx = self.dimord.index("freq")
    taperIdx = self.dimord.index("taper")
    # idx[chanIdx] = self._selection.channel

    # No time-frequency shenanigans: this is a simple power-spectrum (line-plot)
    if not isTimeFrequency:
        
        # Generic titles for figures
        overlayTitle = "Overlay of {} datasets"
    
        # Either create new figure or fetch existing
        if fig is None:
            fig, ax = plt.subplots(1, tight_layout=True, squeeze=True,
                                   figsize=pltConfig["singleFigSize"])
            ax.set_xlabel("frequency [Hz]", size=pltConfig["singleLabelSize"])            
            ax.tick_params(axis="both", labelsize=pltConfig["singleTickSize"])
            ax.autoscale(enable=True, axis="x", tight=True)
            fig.objCount = 0
        else:
            ax, = fig.get_axes()        
        
        if not avg_channels and not avg_tapers and nTap > 1:
            msg = "Either channels or trials need to be averaged for single-panel plot"
            SPYWarning(msg)
            return
        
        if avg_channels and not avg_tapers:
            
            panelTitle = "{} tapers averaged across {} channels and {} trials"
            
            # Compute channel-/trial-average time-course: 2D array with slice/list
            # selection does not require fancy indexing - no need to check this here
            pltArr = np.zeros((nFreq, nTap), dtype=self.data.dtype)
            for trlno in trlList:
                trlArr = self._get_trial(trlno)[tuple(idx)].mean(axis=chanIdx).squeeze()
                pltArr += np.swapaxes(trlArr, freqIdx, 0)
            pltArr /= nTrials
            
            ax.plot(freqArr, pltArr, label=os.path.basename(self.filename))
            ax.set_xlim([time[0], time[-1]])
            if grid is not None:
                ax.grid(grid)
            
            
        if avg_tapers and not avg_channels:
            pass
        if avg_tapers and avg_channels:
            pass
        
    else:
        
        if not avg_channels or (not avg_tapers and nTap > 1):
            msg = "Time-frequency visualization requires averaging across both tapers and channels"
            SPYWarning(msg)
    


